package training.iqgateway.services;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.bson.types.ObjectId;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import training.iqgateway.dtos.AppointmentBookingRequest;
import training.iqgateway.dtos.AppointmentResponse;
import training.iqgateway.entities.Appointment;
import training.iqgateway.entities.AppointmentNote;
import training.iqgateway.entities.AppointmentStatus;
import training.iqgateway.entities.Doctor;
import training.iqgateway.entities.DoctorAvailability;
import training.iqgateway.entities.InsuranceCoverageStatus;
import training.iqgateway.entities.Patient;
import training.iqgateway.repositories.AppointmentNoteRepository;
import training.iqgateway.repositories.AppointmentRepository;
import training.iqgateway.repositories.DoctorAvalilabilityRepository;
import training.iqgateway.repositories.DoctorRepository;
import training.iqgateway.repositories.PatientRepository;

@Service
public class AppointmentService {

	@Autowired
    private AppointmentRepository appointmentRepository;
    
    @Autowired
    private DoctorRepository doctorRepository;
    
    @Autowired
    private PatientRepository patientRepository;
    
    @Autowired
    private DoctorAvalilabilityRepository availabilityRepository;
    
    @Autowired
    private NotificationService notificationService;
    
    @Autowired
    private AppointmentNoteRepository noteRepository;
//    
    public AppointmentResponse bookAppointment(AppointmentBookingRequest request) {
        try {
            // Validate doctor availability
        	System.out.println("Booking appointment for doctor: " + request.getDoctorId() + 
				" at " + request.getScheduledAt());
            if (!isDoctorAvailable(request.getDoctorId(), request.getScheduledAt())) {
                return new AppointmentResponse(null, "Doctor is not available at the requested time");
            }
            
            // Check for conflicting appointments
            List<Appointment> conflicts = appointmentRepository.findConflictingAppointments(
                request.getDoctorId(), request.getScheduledAt());
            
            if (!conflicts.isEmpty()) {
                return new AppointmentResponse(null, "Time slot is already booked");
            }
            
            // Fetch Patient and Doctor entities
            Patient patient = patientRepository.findById(request.getPatientId()).orElse(null);
            System.out.println("Patient found: " + (patient != null ? patient.getId() : "null"));
            Doctor doctor = doctorRepository.findById(request.getDoctorId()).orElse(null);
            System.out.println("Doctor found: " + (doctor != null ? doctor.getId() : "null"));
            
            if (patient == null || doctor == null) {
                return new AppointmentResponse(null, "Patient or Doctor not found");
            }
            
            // Create appointment
            Appointment appointment = new Appointment();
            appointment.setPatient(patient);
            appointment.setDoctor(doctor);
            appointment.setAppointmentDate(request.getScheduledAt());
            String coverageStatusString = request.getInsuranceCoverageStatus();
            if (coverageStatusString != null) {
                InsuranceCoverageStatus status = InsuranceCoverageStatus.valueOf(coverageStatusString.toUpperCase());
                appointment.setInsuranceCoverageStatus(status);
            }
            appointment.setCoverageCheckDate(LocalDateTime.now());
            appointment.setCreatedAt(LocalDateTime.now());
            appointment.setStatus(AppointmentStatus.BOOKED); // Assuming enum value
            
            Appointment savedAppointment = appointmentRepository.save(appointment);
            
            // Create appointment note
            createAppointmentNote(savedAppointment.getId(), 
                "Appointment booked for " + request.getScheduledAt(), "booking");
            
            // Send notification to doctor
            List<String> fromNotSer = notificationService.notifyDoctorOfNewAppointment(
                request.getDoctorId(), savedAppointment.getId(), request.getPatientId());
            System.out.println("Notification sent to doctor: " + fromNotSer);
            
            return new AppointmentResponse(
				savedAppointment.getId(), 
				fromNotSer.get(1), 
				fromNotSer.get(0), 
				savedAppointment.getAppointmentDate(), 
				savedAppointment.getStatus().toString(), 
				"Appointment booked successfully");
            
        } catch (Exception e) {
            return new AppointmentResponse(null, "Error booking appointment: " + e.getMessage());
        }
    }

   
    // Doctor accepts appointment
    public AppointmentResponse acceptAppointment(String appointmentId, String doctorId) {
        try {
            Optional<Appointment> appointmentOpt = appointmentRepository.findById(appointmentId);
            
            if (!appointmentOpt.isPresent()) {
                return new AppointmentResponse(appointmentId, "Appointment not found");
            }
            
            Appointment appointment = appointmentOpt.get();
            
            if (!appointment.getDoctor().getId().equals(doctorId)) {
                return new AppointmentResponse(appointmentId, "Unauthorized access");
            }
            
            if (!"BOOKED".equals(appointment.getStatus().toString())) {
                return new AppointmentResponse(appointmentId, 
                    "Cannot accept appointment. Current status: " + appointment.getStatus());
            }
            
            // Update status to confirmed
            appointment.setStatus(AppointmentStatus.CONFIRMED);
            appointmentRepository.save(appointment);
            
            // Create note
            createAppointmentNote(appointmentId, "Appointment confirmed by doctor", "status_update");
            
            // Notify patient
            notificationService.notifyPatientOfAppointmentUpdate(
                appointment.getPatient().getId(), appointmentId, 
                "Your appointment has been confirmed by the doctor.");
            
            return new AppointmentResponse(
				appointmentId, 
				appointment.getDoctor().getUser().getUsername(), // Doctor's name
				appointment.getPatient().getUser().getUsername(), // Patient's name
				appointment.getAppointmentDate(), 
				appointment.getStatus().toString(), 
				"Appointment accepted successfully");
            
        } catch (Exception e) {
            return new AppointmentResponse(appointmentId, "Error accepting appointment: " + e.getMessage());
        }
    }
//    
    // Doctor rejects appointment
    public AppointmentResponse rejectAppointment(String appointmentId, String doctorId, String reason) {
        try {
            Optional<Appointment> appointmentOpt = appointmentRepository.findById(appointmentId);
            
            if (!appointmentOpt.isPresent()) {
                return new AppointmentResponse(appointmentId, "Appointment not found");
            }
            
            Appointment appointment = appointmentOpt.get();
            
            if (!appointment.getDoctor().getId().equals(doctorId)) {
                return new AppointmentResponse(appointmentId, "Unauthorized access");
            }
            
            if (!"BOOKED".equals(appointment.getStatus().toString())) {
                return new AppointmentResponse(appointmentId, 
                    "Cannot reject appointment. Current status: " + appointment.getStatus());
            }
            
            // Update status to cancelled
            appointment.setStatus(AppointmentStatus.REJECTED);
            appointmentRepository.save(appointment);
            
            // Create note
            String noteText = reason != null ? 
                "Appointment cancelled by doctor. Reason: " + reason : 
                "Appointment cancelled by doctor";
            createAppointmentNote(appointmentId, noteText, "cancellation");
            
            // Notify patient
            String notificationMessage = reason != null ? 
                "Your appointment has been cancelled by the doctor. Reason: " + reason :
                "Your appointment has been cancelled by the doctor.";
            
            notificationService.notifyPatientOfAppointmentUpdate(
                appointment.getPatient().getId(), appointmentId, notificationMessage);
            
            return new AppointmentResponse(appointmentId, 
				appointment.getDoctor().getUser().getUsername(), // Doctor's name
				appointment.getPatient().getUser().getUsername(), // Patient's name
				appointment.getAppointmentDate(), 
				appointment.getStatus().toString(), 
				"Appointment rejected successfully");
            
        } catch (Exception e) {
            return new AppointmentResponse(appointmentId, "Error rejecting appointment: " + e.getMessage());
        }
    }
//    
    // Get pending appointments for doctor
    public List<Appointment> getPendingAppointments(String doctorId) {
        System.out.println("Looking for appointments with doctorId: " + doctorId);
        System.out.println("Status: " + AppointmentStatus.BOOKED);
        
        List<Appointment> allAppointments = appointmentRepository.findAll();
        System.out.println("Total appointments in database: " + allAppointments.size());
        
        // ADD THIS LOOP to see what's actually in the database:
        for (Appointment apt : allAppointments) {
            System.out.println("Appointment ID: " + apt.getId() + 
                              ", Doctor ID: " + apt.getDoctor().getId() + 
                             
                              ", Status: " + apt.getStatus());
        }
        
        List<Appointment> result = appointmentRepository.findByDoctorIdAndStatus(doctorId, AppointmentStatus.BOOKED);
        System.out.println("Query result size: " + result.size());
        
        return result;
    }
//    
    // Get available time slots
    public List<LocalDateTime> getAvailableSlots(String doctorId, LocalDate date) {
        String dayOfWeek = date.getDayOfWeek().toString().toLowerCase();
        ObjectId doctorObjectId = new ObjectId(doctorId);
        DoctorAvailability availability = availabilityRepository
            .findByDoctorIdAndDayOfWeekAndIsAvailable(doctorObjectId, dayOfWeek, true);
        
        if (availability == null) {
            return new ArrayList<>();
        }
        
        // Get existing appointments for the day
        LocalDateTime startOfDay = date.atStartOfDay();
        LocalDateTime endOfDay = date.atTime(23, 59, 59);
        
        List<Appointment> existingAppointments = appointmentRepository
            .findAppointmentsByDoctorAndDateRange(doctorId, startOfDay, endOfDay);
        
        // Generate available slots
        List<LocalDateTime> availableSlots = new ArrayList<>();
        
        // Extract time from LocalDateTime fields
        LocalTime currentTime = availability.getStartTime().toLocalTime();
        LocalTime endTime = availability.getEndTime().toLocalTime();
        int duration = availability.getAppointmentDuration() > 0 ? 
            availability.getAppointmentDuration() : 30;
        
        while (currentTime.isBefore(endTime)) {
            LocalDateTime slotDateTime = date.atTime(currentTime);
            
            // Check if slot is not booked
            boolean isBooked = existingAppointments.stream()
                .anyMatch(apt -> apt.getAppointmentDate() != null && 
                               apt.getAppointmentDate().equals(slotDateTime));
            
            if (!isBooked) {
                availableSlots.add(slotDateTime);
            }
            
            currentTime = currentTime.plusMinutes(duration);
        }
        
        return availableSlots;
    }
//    // Check if doctor is available
    private boolean isDoctorAvailable(String doctorId, LocalDateTime requestedTime) {
        String dayOfWeek = requestedTime.getDayOfWeek().toString().toUpperCase();
        Doctor doctor = doctorRepository.findById(doctorId)
			.orElseThrow(() -> new IllegalArgumentException("Doctor not found"));
        ObjectId doctorObjectId = new ObjectId(doctor.getId());
        System.out.println(dayOfWeek);
        DoctorAvailability availability = availabilityRepository
            .findByDoctorIdAndDayOfWeekAndIsAvailable(doctorObjectId, dayOfWeek, true);
        
  	  System.out.println(availability);
        if (availability == null) {
            return false;
        }
        System.out.println(availability.getStartTime());
        // Extract time part from LocalDateTime fields
        LocalTime requestedTimeOnly = requestedTime.toLocalTime();
        LocalTime startTime = availability.getStartTime().toLocalTime();
        LocalTime endTime = availability.getEndTime().toLocalTime();
        
        return !requestedTimeOnly.isBefore(startTime) && 
               !requestedTimeOnly.isAfter(endTime);
    }
   
    // Create appointment note
    private void createAppointmentNote(String appointmentId, String noteText, String noteType) {
        AppointmentNote note = new AppointmentNote();
        Appointment appointment = appointmentRepository.findById(appointmentId)
			.orElseThrow(() -> new IllegalArgumentException("Appointment not found"));
        note.setAppointment(appointment);
        note.setNoteText(noteText);
        note.setNoteType(noteType);
        noteRepository.save(note);
    }
    
    // Get appointment details
    public Appointment getAppointmentDetails(String appointmentId) {
        return appointmentRepository.findById(appointmentId).orElse(null);
    }
    
    public List<Appointment> getAllAppointments() {
		return appointmentRepository.findAll();
	}
}
